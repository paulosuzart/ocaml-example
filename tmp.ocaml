module CharSet = Set.Make(Char)

module type CONTAINER =
  sig
    type element 
    type container
    val contains : container -> element -> bool
    val add : container -> element -> container
    val empty : unit -> container
  end

module SetContainer : (CONTAINER with type element = char) = 
  struct
    module CharSet = Set.Make(Char)
    type element = char
    type container = CharSet.t

    let contains con c = 
      match CharSet.find_opt c con with 
        Some _ -> true
      | None -> false

    let add con c = CharSet.add c con

    let empty () = CharSet.empty
  end

(* let mySet : (module CONTAINER) = (module SetContainer)
module F = (val mySet) *)

let solve3 word (module M : CONTAINER with type element = char) =
  let rec solve2 con word' = match word'() with
      Seq.Cons (c, _) when M.contains con c -> Some c
    | Seq.Cons (c, xs) -> solve2 (M.add con c) xs
    | Nil -> None in
  let empty = M.empty () and word_seq = String.to_seq word in
  solve2 empty word_seq
  

let setSolve word =
  let mySet = (module SetContainer : CONTAINER with type element = char) in
  solve3 word mySet


(* Adds a char to the Set and returns the new instance and a 
bool indicating if the insertion suceeded *)
let add achar target =
    let added = CharSet.add achar target in
    target <> added, added

let add_ht c ht = 
  let lbefore = Hashtbl.length ht in
  Hashtbl.replace ht c c;
  lbefore < Hashtbl.length ht, ht

let rec solve' word' container add_fn = match word'() with
    Seq.Cons (c, xs) -> 
        (match add_fn c container with
          (true, s)  -> solve' xs s add_fn
          | _ -> Some c)
  | _ -> None


(* Finds the first repeated character in a word usingn a set *)
let solve word =
  Dream.info (fun log -> log "Solving [%s] using set" word);
  setSolve word

(* Finds the first repeated character in a word using a hash table *)
let solve_ht word =
  Dream.info (fun log -> log "Solving [%s] using hash table" word);
  let size = String.length word and seq = String.to_seq word in
  solve' seq (Hashtbl.create size) add_ht

(* Finds the repetition using Set or Hashtable *)
let res w s = 
  let res' = match s with
      Some "set" -> solve w
    | _ -> solve_ht w in
  match res' with
    Some c -> Printf.sprintf "Found %c" c
  | None -> "No repetition found"

let () = 
  Dream.run ~debug:true
  @@ Dream.logger
  @@ Dream.router [
    Dream.get "/find_repeated" (fun req -> match Dream.query "word" req with 
                  | None -> Dream.empty `Bad_Request
                  | Some word -> Dream.html (res word (Dream.query "s" req)))
  ]
  @@ Dream.not_found